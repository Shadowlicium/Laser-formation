name: Deploy VM from Issue (PGP -> comment)

on:
  issues:
    types: [opened]

permissions:
  contents: read
  actions: write
  issues: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4

      - name: Install deps (jq, gpg, openssh)
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq gnupg openssh-client gettext-base

      - name: Parse Issue Form fields (robuste)
        id: parse
        shell: bash
        run: |
          set -euo pipefail
          BODY='${{ github.event.issue.body }}'
          BODY=$(printf "%s" "$BODY" | sed 's/\r$//')

          get_field_prefix () {
            awk -v pref="$1" '
              $0 ~ "^### " pref {flag=1; next}
              /^### / && flag {flag=0}
              flag
            ' <<< "$BODY"
          }

          NOM=$(get_field_prefix "Nom de la machine" | tr -d '\r' | xargs)
          PGP=$(get_field_prefix "Cl√© PGP publique" | sed 's/\r$//')

          echo "NOM=$NOM" >> "$GITHUB_OUTPUT"
          {
            echo "PGP<<EOF"
            printf '%s\n' "$PGP"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Validate inputs
        shell: bash
        run: |
          set -euo pipefail
          if ! [[ "${{ steps.parse.outputs.NOM }}" =~ ^[a-z0-9-]{3,32}$ ]]; then
            echo "Nom invalide (3‚Äì32, a‚Äìz, 0‚Äì9, -)."; exit 1
          fi
          if ! grep -q "BEGIN PGP PUBLIC KEY BLOCK" <<< "${{ steps.parse.outputs.PGP }}"; then
            echo "Cl√© PGP publique absente ou invalide."; exit 1
          fi

      - name: Generate SSH keypair (ed25519)
        id: ssh
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p /tmp/keys
          ssh-keygen -t ed25519 -f "/tmp/keys/${{ steps.parse.outputs.NOM }}" -N "" -C "${{ steps.parse.outputs.NOM }}@laser"
          echo "PUB=/tmp/keys/${{ steps.parse.outputs.NOM }}.pub"  >> "$GITHUB_OUTPUT"
          echo "PRIV=/tmp/keys/${{ steps.parse.outputs.NOM }}"      >> "$GITHUB_OUTPUT"

      - name: Import PGP and encrypt SSH private (armored)
        id: pgp
        shell: bash
        env:
          NOM:  ${{ steps.parse.outputs.NOM }}
          PRIV: ${{ steps.ssh.outputs.PRIV }}
        run: |
          set -euo pipefail
          echo "${{ steps.parse.outputs.PGP }}" > /tmp/client_pub.asc
          gpg --batch --yes --import /tmp/client_pub.asc
          FPR=$(gpg --with-colons --import-options show-only --import /tmp/client_pub.asc | awk -F: '/^fpr:/ {print $10; exit}')
          [[ -n "$FPR" && "$FPR" =~ ^[0-9A-Fa-f]{40}$ ]] || { echo "Fingerprint PGP invalide"; exit 1; }
          echo "$FPR:6:" | gpg --batch --yes --import-ownertrust
          gpg --batch --yes --trust-model always --pinentry-mode loopback \
            --recipient "$FPR" \
            --armor \
            --output "/tmp/${NOM}.key.asc" \
            --encrypt "$PRIV"
          echo "ARMOR_PATH=/tmp/${NOM}.key.asc" >> "$GITHUB_OUTPUT"

      - name: Upload cloud-init snippet to Proxmox
        id: upload
        shell: bash
        env:
          PVE_HOST: ${{ secrets.PVE_HOST }}
          PVE_SSH_USER: ${{ secrets.PVE_SSH_USER }}
          PVE_SSH_KEY: ${{ secrets.PVE_SSH_KEY }}
          PVE_SSH_PORT: ${{ secrets.PVE_SSH_PORT }}
        run: |
          set -euo pipefail
          USERNAME="${{ steps.parse.outputs.NOM }}"
          PUBKEY=$(tr -d '\r\n' < "/tmp/keys/${USERNAME}.pub")
          CLOUD_FILE="cloudinit-${USERNAME}.yml"
          TEMPLATE="infra/tofu/cloudinit.tpl"

          if [ ! -f "$TEMPLATE" ]; then
            echo "Template manquant: $TEMPLATE" >&2
            exit 1
          fi

          mkdir -p ~/.ssh

          echo "Generation du snippet a partir du template..."
          export USERNAME PUBKEY
          envsubst '${USERNAME} ${PUBKEY}' < "$TEMPLATE" > "$CLOUD_FILE"

          echo "${PVE_SSH_KEY}" > /tmp/key.pem
          chmod 600 /tmp/key.pem
          ssh-keyscan -p "${PVE_SSH_PORT:-32222}" "${PVE_HOST}" >> ~/.ssh/known_hosts

          echo "Upload du snippet sur ${PVE_HOST}:${PVE_SSH_PORT:-32222}..."
          scp -P "${PVE_SSH_PORT:-32222}" -i /tmp/key.pem -o StrictHostKeyChecking=yes \
            "$CLOUD_FILE" "${PVE_SSH_USER}@${PVE_HOST}:/var/lib/vz/snippets/"

          echo "CLOUD_FILE_NAME=$CLOUD_FILE" >> "$GITHUB_OUTPUT"

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: "1.7.0"

      - name: tofu init + apply
        working-directory: infra/tofu
        shell: bash
        env:
          PVE_API_URL:      ${{ secrets.PVE_API_URL }}
          PVE_TOKEN_ID:     ${{ secrets.PVE_TOKEN_ID }}
          PVE_TLS_INSECURE: ${{ secrets.PVE_TLS_INSECURE }}
        run: |
          set -euo pipefail
          tofu init
          USERS_JSON=$(jq -n --arg u "${{ steps.parse.outputs.NOM }}" '[ $u ]')
          tofu apply -auto-approve \
            -var "users=${USERS_JSON}" \
            -var "ssh_pub_key=${{ steps.ssh.outputs.PUB }}" \
            -var "pve_api_url=${PVE_API_URL}" \
            -var "pve_token_id=${PVE_TOKEN_ID}" \
            -var "pve_tls_insecure=${PVE_TLS_INSECURE}"

      - name: Capture VM outputs
        id: vmout
        working-directory: infra/tofu
        shell: bash
        run: |
          set -euo pipefail
          if tofu output -json vms > /tmp/vm_info.json 2>/dev/null; then
            {
              echo "VM_JSON<<EOF"
              cat /tmp/vm_info.json
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "VM_JSON={}" >> "$GITHUB_OUTPUT"
          fi
          
      - name: Load armored key content for comment
        id: load
        shell: bash
        env:
          PVE_HOST:     ${{ secrets.PVE_HOST }}
          PVE_SSH_USER: ${{ secrets.PVE_SSH_USER }}
          PVE_SSH_KEY:  ${{ secrets.PVE_SSH_KEY }}
          PVE_SSH_PORT: ${{ secrets.PVE_SSH_PORT }} # ex: 32222
        run: |
          set -euo pipefail

          VM_JSON_FILE="/tmp/vm_info.json"
          if [ ! -f "$VM_JSON_FILE" ]; then            # MAC: ${{ steps.mac.outputs.MAC }}
            echo "‚ùå /tmp/vm_info.json introuvable"
            exit 0
          fi

          VMID="$(jq -r 'to_entries[0].value.vmid // empty' "$VM_JSON_FILE")"
          NODE="$(jq -r 'to_entries[0].value.node // empty' "$VM_JSON_FILE")"
          if [ -z "$VMID" ] || [ "$VMID" = "null" ]; then
            echo "‚ùå VMID manquant dans les outputs"
            exit 0
          fi

          # Pr√©pare cl√©/known_hosts
          echo "${PVE_SSH_KEY}" > /tmp/pve_key.pem
          chmod 600 /tmp/pve_key.pem
          PORT="${PVE_SSH_PORT:-32222}"
          mkdir -p ~/.ssh
          ssh-keyscan -p "$PORT" "$PVE_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

          # Si le node n'est pas renseign√© par Terraform, on le d√©duit
          if [ -z "${NODE:-}" ] || [ "$NODE" = "null" ]; then
            echo "‚ÑπÔ∏è Node absent ‚Üí d√©tection via /cluster/resources‚Ä¶"
            RESP_NODE="$(ssh -p "$PORT" -i /tmp/pve_key.pem -o StrictHostKeyChecking=yes \
              "${PVE_SSH_USER}@${PVE_HOST}" \
              "sudo pvesh get /cluster/resources --type vm" || true)"
            NODE="$(printf '%s' "$RESP_NODE" | grep -oE '\"vmid\":\s*'${VMID}',[^}]+' | grep -oE '\"node\":\"[^"]+\"' | cut -d: -f2 | tr -d '\"')"
          fi

          if [ -z "${NODE:-}" ] || [ "$NODE" = "null" ]; then
            echo "‚ùå Impossible d‚Äôidentifier le node de la VM $VMID"
            exit 0
          fi

          echo "üîç VMID=$VMID  NODE=$NODE"

          ARMOR_CONTENT=$(sed -e 's/`/\\`/g' "$FILE")
          {
            echo "ARMOR<<EOF"
            printf '%s\n' "$ARMOR_CONTENT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Comment the issue with encrypted key + VM info
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.issue.number }}
          body: |
            ‚úÖ **VM cr√©√©e pour** `${{ steps.parse.outputs.NOM }}`
            **Infos VM (outputs)** :
            ```json
            ${{ steps.vmout.outputs.VM_JSON }}
            ```

            **Nom de la machine :**
            ```bash
            debian-${{ steps.parse.outputs.NOM }}
            ```

            **Cl√© priv√©e SSH chiffr√©e (PGP)** ‚Äî copie ce bloc dans `id_ed25519.asc` puis d√©chiffre-la :
            ```text
            ${{ steps.load.outputs.ARMOR }}
            ```

            **Connexion SSH (exemple) :**
            ```bash
            gpg --decrypt id_ed25519.asc > id_ed25519
            chmod 600 id_ed25519
            ssh -i ./id_ed25519 ${{ steps.parse.outputs.NOM }}@debian-${{ steps.parse.outputs.NOM }}
            ```

      - name: Remove snippet from Proxmox
        if: always()
        shell: bash
        env:
          PVE_HOST: ${{ secrets.PVE_HOST }}
          PVE_SSH_USER: ${{ secrets.PVE_SSH_USER }}
          PVE_SSH_KEY: ${{ secrets.PVE_SSH_KEY }}
          PVE_SSH_PORT: ${{ secrets.PVE_SSH_PORT }}
        run: |
          set -euo pipefail
          USERNAME="${{ steps.parse.outputs.NOM }}"
          FILE_NAME="/var/lib/vz/snippets/cloudinit-${USERNAME}.yml"
          echo "${PVE_SSH_KEY}" > /tmp/key.pem
          chmod 600 /tmp/key.pem
          mkdir -p ~/.ssh
          ssh-keyscan -p "${PVE_SSH_PORT:-32222}" "${PVE_HOST}" >> ~/.ssh/known_hosts
          echo "Suppression du snippet distant ${FILE_NAME}"
          ssh -p "${PVE_SSH_PORT:-32222}" -i /tmp/key.pem -o StrictHostKeyChecking=yes \
            "${PVE_SSH_USER}@${PVE_HOST}" "rm -f ${FILE_NAME}" || true

      - name: Cleanup sensitive files
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          shred -u /tmp/key.pem || true
          shred -u "${{ steps.ssh.outputs.PRIV }}" || true
          shred -u "${{ steps.ssh.outputs.PUB }}" || true
          rm -f /tmp/client_pub.asc || true
          rm -f "/tmp/${{ steps.parse.outputs.NOM }}.key.asc" || true

name: Deploy VM from Issue (PGP â†’ comment)

on:
  issues:
    types: [opened]

permissions:
  contents: read
  actions: write
  issues: write

jobs:
  deploy:
    runs-on: self-hosted

    steps:
      - uses: actions/checkout@v4

      # (Optionnel) ExÃ©cuter seulement si le label 'deploy-request' est prÃ©sent
      # - name: Guard (require deploy-request label)
      #   run: |
      #     echo '${{ toJson(github.event.issue.labels.*.name) }}' | grep -wq 'deploy-request' \
      #     || { echo "No 'deploy-request' label â†’ exit."; exit 0; }

      - name: Install deps (jq, gpg)
        run: sudo apt-get update && sudo apt-get install -y jq gnupg

      - name: Debug event (voir le corps de lâ€™issue)
        run: |
          printf "==== ISSUE BODY START ====\n%s\n==== ISSUE BODY END ====\n" '${{ github.event.issue.body }}'

      - name: Parse Issue Form fields (robuste)
        id: parse
        run: |
          BODY='${{ github.event.issue.body }}'
          BODY=$(printf "%s" "$BODY" | sed 's/\r$//')  # normaliser CRLF

          get_field_prefix () {
            awk -v pref="$1" '
              $0 ~ "^### " pref {flag=1; next}
              /^### / && flag {flag=0}
              flag
            ' <<< "$BODY"
          }

          NOM=$(get_field_prefix "Nom de la machine" | tr -d '\r' | xargs)
          PGP=$(get_field_prefix "ClÃ© PGP publique" | sed 's/\r$//')

          echo "NOM=$NOM" >> $GITHUB_OUTPUT
          echo "PGP<<EOF"  >> $GITHUB_OUTPUT
          echo "$PGP"      >> $GITHUB_OUTPUT
          echo "EOF"       >> $GITHUB_OUTPUT

          echo ">> NOM=[$NOM]"
          echo ">> PGP prÃ©sent? $( [ -n "$PGP" ] && echo oui || echo non )"

      - name: Validate inputs
        run: |
          if ! [[ "${{ steps.parse.outputs.NOM }}" =~ ^[a-z0-9-]{3,32}$ ]]; then
            echo "Nom invalide (3â€“32, aâ€“z, 0â€“9, -)."; exit 1
          fi
          if ! grep -q "BEGIN PGP PUBLIC KEY BLOCK" <<< "${{ steps.parse.outputs.PGP }}"; then
            echo "ClÃ© PGP publique absente ou invalide."; exit 1
          fi

      - name: Generate SSH keypair (ed25519)
        id: ssh
        run: |
          mkdir -p /tmp/keys
          ssh-keygen -t ed25519 -f /tmp/keys/${{ steps.parse.outputs.NOM }} -N "" -C "${{ steps.parse.outputs.NOM }}@laser"
          echo "PUB=/tmp/keys/${{ steps.parse.outputs.NOM }}.pub"  >> $GITHUB_OUTPUT
          echo "PRIV=/tmp/keys/${{ steps.parse.outputs.NOM }}"      >> $GITHUB_OUTPUT
          echo "ClÃ© publique:"
          cat /tmp/keys/${{ steps.parse.outputs.NOM }}.pub

      - name: Import PGP and encrypt SSH private (non-interactive, armored)
        id: pgp
        env:
          NOM:  ${{ steps.parse.outputs.NOM }}
          PRIV: ${{ steps.ssh.outputs.PRIV }}
        run: |
          set -euo pipefail
          echo "${{ steps.parse.outputs.PGP }}" > /tmp/client_pub.asc
          gpg --batch --yes --import /tmp/client_pub.asc
          FPR=$(gpg --with-colons --import-options show-only --import /tmp/client_pub.asc | awk -F: '/^fpr:/ {print $10; exit}')
          [[ -n "$FPR" && "$FPR" =~ ^[0-9A-F]{40}$ ]] || { echo "Fingerprint PGP invalide"; exit 1; }
          echo "$FPR:6:" | gpg --batch --yes --import-ownertrust
          gpg --batch --yes --trust-model always --pinentry-mode loopback \
              --recipient "$FPR" \
              --armor \
              --output "/tmp/${NOM}.key.asc" \
              --encrypt "$PRIV"
          echo "ARMOR=/tmp/${NOM}.key.asc" >> $GITHUB_OUTPUT

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: "1.7.0"

      - name: tofu init + apply
        working-directory: infra/tofu
        env:
          PVE_API_URL:      ${{ secrets.PVE_API_URL }}
          PVE_TOKEN_ID:     ${{ secrets.PVE_TOKEN_ID }}      # ðŸš¨ ce secret doit contenir le token COMPLET: user@realm!token=uuid
          PVE_TLS_INSECURE: ${{ secrets.PVE_TLS_INSECURE }}  # true/false
        run: |
          set -euo pipefail

          # Garde-fous
          [ -n "${PVE_API_URL:-}" ]  || { echo "PVE_API_URL vide"; exit 1; }
          [ -n "${PVE_TOKEN_ID:-}" ] || { echo "PVE_TOKEN_ID vide"; exit 1; }

          # Normaliser bool â†’ true/false strict
          case "${PVE_TLS_INSECURE:-}" in
            1|true|TRUE|True|yes|YES) INSECURE=true ;;
            0|false|FALSE|False|no|NO|"") INSECURE=false ;;
            *) echo "PVE_TLS_INSECURE invalide: '${PVE_TLS_INSECURE}'"; exit 1 ;;
          esac

          tofu init
          USERS_JSON=$(jq -n --arg u "${{ steps.parse.outputs.NOM }}" '[ $u ]')

          tofu apply -auto-approve \
            -var "users=${USERS_JSON}" \
            -var "ssh_pub_key=${{ steps.ssh.outputs.PUB }}" \
            -var "pve_api_url=${PVE_API_URL}" \
            -var "pve_token_id=${PVE_TOKEN_ID}" \
            -var "pve_tls_insecure=${INSECURE}"

      - name: Capture VM outputs
        id: vmout
        working-directory: infra/tofu
        run: |
          if tofu output -json vms > /tmp/vm_info.json 2>/dev/null; then
            echo "VM_JSON<<EOF" >> $GITHUB_OUTPUT
            cat /tmp/vm_info.json >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "VM_JSON={}" >> $GITHUB_OUTPUT
          fi

      - name: Load armored key content for comment
        id: load
        run: |
          ARMOR_CONTENT=$(sed -e 's/`/\\`/g' /tmp/${{ steps.parse.outputs.NOM }}.key.asc)
          echo "ARMOR_CONTENT<<EOF" >> $GITHUB_OUTPUT
          echo "$ARMOR_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Comment the issue with encrypted key + VM info
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.issue.number }}
          body: |
            âœ… **VM crÃ©Ã©e pour** `${{ steps.parse.outputs.NOM }}`
            **Infos VM (outputs)** :
            ```json
            ${{ steps.vmout.outputs.VM_JSON }}
            ```

            **ClÃ© privÃ©e SSH chiffrÃ©e (PGP)** â€” copie ce bloc dans `id_ed25519.asc` puis dÃ©chiffre-la :
            ```text
            ${{ steps.load.outputs.ARMOR_CONTENT }}
            ```

            **DÃ©chiffrement :**
            ```bash
            gpg --decrypt id_ed25519.asc > id_ed25519
            chmod 600 id_ed25519
            ssh -i ./id_ed25519 nono@<IP_de_ta_VM>
            ```

      - name: Cleanup sensitive files
        if: always()
        run: |
          shred -u "${{ steps.ssh.outputs.PRIV }}" || true
          shred -u "${{ steps.ssh.outputs.PUB }}"  || true
          rm -f /tmp/client_pub.asc || true
          rm -f /tmp/${{ steps.parse.outputs.NOM }}.key.asc || true

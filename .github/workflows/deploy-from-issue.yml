name: Deploy VM from Issue (PGP → comment)

on:
  issues:
    types: [opened]

permissions:
  contents: read
  actions: write
  issues: write

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install deps (jq, gpg, openssh)
        run: sudo apt-get update && sudo apt-get install -y jq gnupg openssh-client

      - name: Parse Issue Form fields (robuste)
        name: Deploy VM from Issue (PGP → comment)
    # Optionnel : pré-autoriser la fingerprint SSH
    ssh-keyscan -p "${PVE_SSH_PORT:-32222}" "${PVE_HOST}" >> ~/.ssh/known_hosts

    echo "➡️ Upload du snippet sur ${PVE_HOST}:${PVE_SSH_PORT:-32222}..."
    scp -P "${PVE_SSH_PORT:-32222}" -i /tmp/key.pem -o StrictHostKeyChecking=yes \
      "$CLOUD_FILE" "${PVE_SSH_USER}@${PVE_HOST}:/var/lib/vz/snippets/"

    echo "CLOUD_FILE_NAME=$CLOUD_FILE" >> $GITHUB_OUTPUT

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: "1.7.0"

      - name: tofu init + apply
        working-directory: infra/tofu
        env:
          PVE_API_URL:      ${{ secrets.PVE_API_URL }}
          PVE_TOKEN_ID:     ${{ secrets.PVE_TOKEN_ID }}
          PVE_TLS_INSECURE: ${{ secrets.PVE_TLS_INSECURE }}
        run: |
          set -euo pipefail
          tofu init
          USERS_JSON=$(jq -n --arg u "${{ steps.parse.outputs.NOM }}" '[ $u ]')
          tofu apply -auto-approve \
            -var "users=${USERS_JSON}" \
            -var "ssh_pub_key=${{ steps.ssh.outputs.PUB }}" \
            -var "pve_api_url=${PVE_API_URL}" \
            -var "pve_token_id=${PVE_TOKEN_ID}" \
            -var "pve_tls_insecure=${PVE_TLS_INSECURE}"

      # 🧹 Suppression du snippet après la création de la VM
      - name: Remove snippet from Proxmox
        if: always()
        env:
          PVE_HOST: ${{ secrets.PVE_HOST }}
          PVE_SSH_USER: ${{ secrets.PVE_SSH_USER }}
          PVE_SSH_KEY: ${{ secrets.PVE_SSH_KEY }}
        run: |
          set -euo pipefail
          USERNAME="${{ steps.parse.outputs.NOM }}"
          FILE_NAME="/var/lib/vz/snippets/cloudinit-${USERNAME}.yml"

          echo "${PVE_SSH_KEY}" > /tmp/key.pem
          chmod 600 /tmp/key.pem

          echo "🧹 Suppression du snippet distant ${FILE_NAME}"
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ${PVE_SSH_USER}@${PVE_HOST} "rm -f ${FILE_NAME}" || true

      - name: Capture VM outputs
        id: vmout
        working-directory: infra/tofu
        run: |
          if tofu output -json vms > /tmp/vm_info.json 2>/dev/null; then
            echo "VM_JSON<<EOF" >> $GITHUB_OUTPUT
            cat /tmp/vm_info.json >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "VM_JSON={}" >> $GITHUB_OUTPUT
          fi

      - name: Comment the issue with encrypted key + VM info
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.issue.number }}
          body: |
            ✅ **VM créée pour** `${{ steps.parse.outputs.NOM }}`
         id: parse
        run: |
          BODY='${{ github.event.issue.body }}'
          BODY=$(printf "%s" "$BODY" | sed 's/\r$//')

          get_field_prefix () {
            awk -v pref="$1" '
              $0 ~ "^### " pref {flag=1; next}
              /^### / && flag {flag=0}
              flag
            ' <<< "$BODY"
          }

          NOM=$(get_field_prefix "Nom de la machine" | tr -d '\r' | xargs)
          PGP=$(get_field_prefix "Clé PGP publique" | sed 's/\r$//')

          echo "NOM=$NOM" >> $GITHUB_OUTPUT
          echo "PGP<<EOF"  >> $GITHUB_OUTPUT
          echo "$PGP"      >> $GITHUB_OUTPUT
          echo "EOF"       >> $GITHUB_OUTPUT

      - name: Validate inputs
        run: |
          if ! [[ "${{ steps.parse.outputs.NOM }}" =~ ^[a-z0-9-]{3,32}$ ]]; then
            echo "Nom invalide (3–32, a–z, 0–9, -)."; exit 1
          fi
          if ! grep -q "BEGIN PGP PUBLIC KEY BLOCK" <<< "${{ steps.parse.outputs.PGP }}"; then
            echo "Clé PGP publique absente ou invalide."; exit 1
          fi

      - name: Generate SSH keypair (ed25519)
        id: ssh
        run: |
          mkdir -p /tmp/keys
          ssh-keygen -t ed25519 -f /tmp/keys/${{ steps.parse.outputs.NOM }} -N "" -C "${{ steps.parse.outputs.NOM }}@laser"
          echo "PUB=/tmp/keys/${{ steps.parse.outputs.NOM }}.pub"  >> $GITHUB_OUTPUT
          echo "PRIV=/tmp/keys/${{ steps.parse.outputs.NOM }}"      >> $GITHUB_OUTPUT

      - name: Import PGP and encrypt SSH private (non-interactive, armored)
        id: pgp
        env:
          NOM:  ${{ steps.parse.outputs.NOM }}
          PRIV: ${{ steps.ssh.outputs.PRIV }}
        run: |
          set -euo pipefail
          echo "${{ steps.parse.outputs.PGP }}" > /tmp/client_pub.asc
          gpg --batch --yes --import /tmp/client_pub.asc
          FPR=$(gpg --with-colons --import-options show-only --import /tmp/client_pub.asc | awk -F: '/^fpr:/ {print $10; exit}')
          [[ -n "$FPR" && "$FPR" =~ ^[0-9A-F]{40}$ ]] || { echo "Fingerprint PGP invalide"; exit 1; }
          echo "$FPR:6:" | gpg --batch --yes --import-ownertrust
          gpg --batch --yes --trust-model always --pinentry-mode loopback \
              --recipient "$FPR" \
              --armor \
              --output "/tmp/${NOM}.key.asc" \
              --encrypt "$PRIV"
          echo "ARMOR=/tmp/${NOM}.key.asc" >> $GITHUB_OUTPUT

      # 🟩 Upload du snippet Cloud-Init
      - name: Upload cloud-init snippet to Proxmox
        id: upload
        env:
          PVE_HOST: ${{ secrets.PVE_HOST }}
          PVE_SSH_USER: ${{ secrets.PVE_SSH_USER }}
          PVE_SSH_KEY: ${{ secrets.PVE_SSH_KEY }}
          PVE_SSH_PORT: ${{ secrets.PVE_SSH_PORT }}
        run: |
          set -euo pipefail
          USERNAME="${{ steps.parse.outputs.NOM }}"
          PUBKEY=$(cat /tmp/keys/${USERNAME}.pub)
          CLOUD_FILE="cloudinit-${USERNAME}.yml"

          # Génère le snippet
          cat > "$CLOUD_FILE" <<EOF
#cloud-config
hostname: debian-${USERNAME}
users:
  - name: ${USERNAME}
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    ssh_authorized_keys:
      - ${PUBKEY}
package_update: true
package_upgrade: true
packages:
  - nginx
  - fail2ban
  - vim
  - curl
  - git
  - htop
  - avahi-daemon
runcmd:
  - systemctl enable nginx
  - systemctl start nginx
  - echo "<html><body><h1>VM ${USERNAME}</h1><p>Déployée automatiquement avec OpenTofu + Cloud-Init.</p></body></html>" > /var/www/html/index.html
EOF

          echo "${PVE_SSH_KEY}" > /tmp/key.pem
          chmod 600 /tmp/key.pem
          ssh-keyscan -p "${PVE_SSH_PORT:-32222}" "${PVE_HOST}" >> ~/.ssh/known_hosts

          echo "➡️ Upload du snippet sur ${PVE_HOST}:${PVE_SSH_PORT:-32222}..."
          scp -P "${PVE_SSH_PORT:-32222}" -i /tmp/key.pem -o StrictHostKeyChecking=yes \
            "$CLOUD_FILE" "${PVE_SSH_USER}@${PVE_HOST}:/var/lib/vz/snippets/"

          echo "CLOUD_FILE_NAME=$CLOUD_FILE" >> $GITHUB_OUTPUT

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: "1.7.0"

      - name: tofu init + apply
        working-directory: infra/tofu
        env:
          PVE_API_URL:      ${{ secrets.PVE_API_URL }}
          PVE_TOKEN_ID:     ${{ secrets.PVE_TOKEN_ID }}
          PVE_TLS_INSECURE: ${{ secrets.PVE_TLS_INSECURE }}
        run: |
          set -euo pipefail
          tofu init
          USERS_JSON=$(jq -n --arg u "${{ steps.parse.outputs.NOM }}" '[ $u ]')
          tofu apply -auto-approve \
            -var "users=${USERS_JSON}" \
            -var "ssh_pub_key=${{ steps.ssh.outputs.PUB }}" \
            -var "pve_api_url=${PVE_API_URL}" \
            -var "pve_token_id=${PVE_TOKEN_ID}" \
            -var "pve_tls_insecure=${PVE_TLS_INSECURE}"

      # 🧹 Suppression du snippet après la création
      - name: Remove snippet from Proxmox
        if: always()
        env:
          PVE_HOST: ${{ secrets.PVE_HOST }}
          PVE_SSH_USER: ${{ secrets.PVE_SSH_USER }}
          PVE_SSH_KEY: ${{ secrets.PVE_SSH_KEY }}
          PVE_SSH_PORT: ${{ secrets.PVE_SSH_PORT }}
        run: |
          set -euo pipefail
          USERNAME="${{ steps.parse.outputs.NOM }}"
          FILE_NAME="/var/lib/vz/snippets/cloudinit-${USERNAME}.yml"

          echo "${PVE_SSH_KEY}" > /tmp/key.pem
          chmod 600 /tmp/key.pem
          ssh-keyscan -p "${PVE_SSH_PORT:-32222}" "${PVE_HOST}" >> ~/.ssh/known_hosts

          echo "🧹 Suppression du snippet distant ${FILE_NAME}"
          ssh -p "${PVE_SSH_PORT:-32222}" -i /tmp/key.pem -o StrictHostKeyChecking=yes \
            "${PVE_SSH_USER}@${PVE_HOST}" "rm -f ${FILE_NAME}" || true

      - name: Capture VM outputs
        id: vmout
        working-directory: infra/tofu
        run: |
          if tofu output -json vms > /tmp/vm_info.json 2>/dev/null; then
            echo "VM_JSON<<EOF" >> $GITHUB_OUTPUT
            cat /tmp/vm_info.json >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "VM_JSON={}" >> $GITHUB_OUTPUT
          fi

      - name: Comment the issue with encrypted key + VM info
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.issue.number }}
          body: |
            ✅ **VM créée pour** `${{ steps.parse.outputs.NOM }}`
            **Infos VM (outputs)** :
            ```json
            ${{ steps.vmout.outputs.VM_JSON }}
            ```
            **Clé privée SSH chiffrée (PGP)** :
            ```text
            ${{ steps.pgp.outputs.ARMOR }}
            ```
            **Déchiffrement :**
            ```bash
            gpg --decrypt id_ed25519.asc > id_ed25519
            chmod 600 id_ed25519
            ssh -i ./id_ed25519 ${{ steps.parse.outputs.NOM }}@<IP_VM>
            ```

      - name: Cleanup sensitive files
        if: always()
        run: |
          shred -u /tmp/key.pem || true
          shred -u "${{ steps.ssh.outputs.PRIV }}" || true
          shred -u "${{ steps.ssh.outputs.PUB }}" || true
          rm -f /tmp/client_pub.asc || true
          rm -f /tmp/${{ steps.parse.outputs.NOM }}.key.asc || true

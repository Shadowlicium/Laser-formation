name: Deploy VM from Issue (PGP → comment)

on:
  issues:
    types: [opened]

permissions:
  contents: read
  actions: write
  issues: write

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install deps (jq, gpg)
        run: sudo apt-get update && sudo apt-get install -y jq gnupg

      - name: Parse Issue Form fields
        id: parse
        run: |
          BODY=$(jq -r '.issue.body' <<< '${{ toJson(github.event) }}')

          # Récupérer les sections du Issue Form
          get_field () {
            awk -v title="$1" '
              $0 ~ "^### "title"$" {flag=1; next}
              /^### / && flag {flag=0}
              flag
            ' <<< "$BODY" | tr -d '\r'
          }

          NOM="$(get_field 'Nom de la machine' | xargs)"
          PGP="$(get_field 'Clé PGP publique')"

          echo "NOM=$NOM" >> $GITHUB_OUTPUT
          echo "PGP<<EOF"  >> $GITHUB_OUTPUT
          echo "$PGP"      >> $GITHUB_OUTPUT
          echo "EOF"       >> $GITHUB_OUTPUT

      - name: Validate inputs
        run: |
          if ! [[ "${{ steps.parse.outputs.NOM }}" =~ ^[a-z0-9-]{3,32}$ ]]; then
            echo "Nom invalide (3–32, a–z, 0–9, -)."; exit 1
          fi
          if ! grep -q "BEGIN PGP PUBLIC KEY BLOCK" <<< "${{ steps.parse.outputs.PGP }}"; then
            echo "Clé PGP publique absente ou invalide."; exit 1
          fi

      - name: Generate SSH keypair (ed25519)
        id: ssh
        run: |
          mkdir -p /tmp/keys
          ssh-keygen -t ed25519 -f /tmp/keys/${{ steps.parse.outputs.NOM }} -N "" -C "${{ steps.parse.outputs.NOM }}@laser"
          echo "PUB=/tmp/keys/${{ steps.parse.outputs.NOM }}.pub"  >> $GITHUB_OUTPUT
          echo "PRIV=/tmp/keys/${{ steps.parse.outputs.NOM }}"      >> $GITHUB_OUTPUT
          echo "Clé publique:"
          cat /tmp/keys/${{ steps.parse.outputs.NOM }}.pub

      - name: Import PGP and encrypt SSH private (non-interactive, armored)
        id: pgp
        env:
          NOM:  ${{ steps.parse.outputs.NOM }}
          PRIV: ${{ steps.ssh.outputs.PRIV }}
        run: |
          set -euo pipefail
          echo "${{ steps.parse.outputs.PGP }}" > /tmp/client_pub.asc
          gpg --batch --yes --import /tmp/client_pub.asc
          FPR=$(gpg --with-colons --import-options show-only --import /tmp/client_pub.asc | awk -F: '/^fpr:/ {print $10; exit}')
          [[ -n "$FPR" && "$FPR" =~ ^[0-9A-F]{40}$ ]] || { echo "Fingerprint PGP invalide"; exit 1; }
          echo "$FPR:6:" | gpg --batch --yes --import-ownertrust
          gpg --batch --yes --trust-model always --pinentry-mode loopback \
              --recipient "$FPR" \
              --armor \
              --output "/tmp/${NOM}.key.asc" \
              --encrypt "$PRIV"
          echo "ARMOR=/tmp/${NOM}.key.asc" >> $GITHUB_OUTPUT

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: "1.7.0"

      - name: tofu init + apply
        working-directory: infra/tofu
        env:
          PVE_API_URL:      ${{ secrets.PVE_API_URL }}
          PVE_API_TOKEN:    ${{ secrets.PVE_API_TOKEN }}       # format complet: user@realm!token=uuid
          PVE_TLS_INSECURE: ${{ secrets.PVE_TLS_INSECURE }}
        run: |
          set -euo pipefail
          # Normaliser bool
          case "${PVE_TLS_INSECURE:-}" in
            1|true|TRUE|True|yes|YES) INSECURE=true ;;
            0|false|FALSE|False|no|NO|"") INSECURE=false ;;
            *) echo "PVE_TLS_INSECURE invalide: '${PVE_TLS_INSECURE}'"; exit 1 ;;
          esac

          tofu init
          USERS_JSON=$(jq -n --arg u "${{ steps.parse.outputs.NOM }}" '[ $u ]')
          tofu apply -auto-approve \
            -var "users=${USERS_JSON}" \
            -var "ssh_pub_key=${{ steps.ssh.outputs.PUB }}" \
            -var "pve_api_url=${PVE_API_URL}" \
            -var "pve_token_id=${PVE_API_TOKEN}" \
            -var "pve_tls_insecure=${INSECURE}"

      - name: Capture VM outputs (optional)
        id: vmout
        working-directory: infra/tofu
        run: |
          tofu output -json vms > /tmp/vm_info.json
          echo "VM_JSON<<EOF" >> $GITHUB_OUTPUT
          cat /tmp/vm_info.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Load armored key content for comment
        id: load
        run: |
          ARMOR_CONTENT=$(sed -e 's/`/\\`/g' /tmp/${{ steps.parse.outputs.NOM }}.key.asc)
          echo "ARMOR_CONTENT<<EOF" >> $GITHUB_OUTPUT
          echo "$ARMOR_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Comment the issue with encrypted key + VM info
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.issue.number }}
          body: |
            ✅ **VM créée pour** `${{ steps.parse.outputs.NOM }}`
            **Infos VM (outputs)** :
            ```json
            ${{ steps.vmout.outputs.VM_JSON || '{}' }}
            ```

            **Clé privée SSH chiffrée (PGP)** — copie ce bloc dans `id_ed25519.asc` puis déchiffre-la :
            ```text
            ${{ steps.load.outputs.ARMOR_CONTENT }}
            ```

            **Déchiffrement :**
            ```bash
            gpg --decrypt id_ed25519.asc > id_ed25519
            chmod 600 id_ed25519
            ssh -i ./id_ed25519 debian@<IP_de_ta_VM>
            ```

      - name: Cleanup sensitive files
        if: always()
        run: |
          shred -u "${{ steps.ssh.outputs.PRIV }}" || true
          shred -u "${{ steps.ssh.outputs.PUB }}"  || true
          rm -f /tmp/client_pub.asc || true
          rm -f /tmp/${{ steps.parse.outputs.NOM }}.key.asc || true
